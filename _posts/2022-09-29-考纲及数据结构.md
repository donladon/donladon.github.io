------
**<font color="500050"> 不积跬步，无以至千里；不积小流，无以成江海。**</font>
------
# 内容目录
- [内容目录](#内容目录)
- [TodoList](#todolist)
- [考试大纲](#考试大纲)
  - [数据结构大纲](#数据结构大纲)
  - [数据库大纲](#数据库大纲)
- [数据结构部分](#数据结构部分)
  - [第一章 绪论](#第一章-绪论)
    - [时间复杂度](#时间复杂度)
  - [第二章 线性表](#第二章-线性表)
  - [第三章 栈、队列和数组](#第三章-栈队列和数组)
  - [第五章 树与二叉树](#第五章-树与二叉树)
  - [第六章 图](#第六章-图)
  - [第七章 查找](#第七章-查找)
  - [第八章 排序](#第八章-排序)

------


# TodoList
 
- [ ] 高数真题10-22
- [x] 政治1000题
- [x] 数据结构二轮
 

------
 
[TOC]

# 数据结构部分

------

## 第一章 绪论

------

## 第二章 线性表

------

## 第三章 栈、队列和数组

------

## 第五章 树与二叉树

### 二叉树的性质

- 叶子结点数等于度为2的结点数加一：N0=N2+1
- 具有n个结点的完全二叉树的高度为log2(n+1)向上取整

### 二叉树的存储结构

> 顺序存储结构

- 比较适合存储完全二叉树和满二叉树

> 链式存储结构

- 用链表结点来存储二叉树中的每个结点
- 在n个结点的二叉链表中，有n+1个空链域，因为有n-1条边，一共2n个结点嘛

### 二叉树的遍历

> 先序遍历

- 递归算法

~~~c
void PreOrder(BiTree T){
    if(T!=NULL){
        visit(T);
        PreOrder(T->lchild); //递归遍历
        PreOrder(T->rchild);
    }
}
~~~

- 非递归算法

~~~c
void InOrder(BiTree T){
    InitStack(S);BiTree p=T;
    while(p||!IsEmpty(S)){
        if(p){
            visit(p);
            Push(S,p);
            p=p->lchild;
        }
        else{
            Pop(S,p);
            p=p->rchild;
        }
    }
}
~~~

> 中序遍历

- 非递归算法

~~~c
void InOrder(BiTree T){
    InitStack(S);BiTree p=T;
    while(p||!IsEmpty(S)){
        if(p){
            Push(S,p);
            p=p->lchild;
        }
        else{
            Pop(S,p);visit(p);
            p=p->rchild;
        }
    }
}
~~~

> 后序遍历

> 层次遍历

- 借助队列实现，比较经典

~~~c
void LevelOrder(BiTree T){
    InitQueue(Q);
    BiTree p;
    EnQueue(Q,T);
    while(!IsEmpty(Q)){
        DeQueue(Q,p);
        visit(p);
        if(p->lchild!=NULL)
            EnQueue(Q,p->lchild)
        if(p->rchild!=NULL)
            EnQueue(Q,p->rchild)    
    }
}
~~~

### 线索二叉树

- 利用n+1个空链域存放先、中、后序信息

~~~c
void Inthread(ThreadTree &p,ThreadTree &pre){
    if(p!=NULL){
        Inthread(p->lchild,pre); //递归，线索化左子树
        if (p->lchild==NULL){	//左子树为空，建立前驱线索
            p->lchild=pre;
            p->ltag=1;
		}
        if(pre!=NULL&&pre->rchild==NULL){
            pre->rchild=p; //建立前驱结点的后继线索
            pre->rtag=1;
        }
        pre=p; //标记当前结点成为刚刚访问过的结点
        Inthread(p->rchild,pre); //递归，线索化右子树
    }
}
~~~

~~~ c
void CreateInthread(ThreadTree T){
    ThreadTree pre=NULL;
    if(T!=NULL){
        Inthread(T,pre);
        pre->rchild=NULL;
        pre->rtag=1;
    }
}
~~~

### 树、森林

- 树->二叉树：孩子兄弟表示法
- 森林->二叉树：每棵树用孩子兄弟，最后把根节点看作兄弟连起来

|    树    |   森林   |  二叉树  |
| :------: | :------: | :------: |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |

------

## 第六章 图

### 图的存储结构

> 邻接矩阵法

- 存储顶点之间邻接关系的**二维数组**称作邻接矩阵
- 无向图的邻接矩阵一定是一个**对称矩阵**且唯一，因此在实际存储邻接矩阵时只需存储上下三角的元素即可
- 对于无向图，第i行非零元素的个数即为该顶点的度；对于有向图，第i行非零元素的个数是其出度，第i列的非零元素是其入度
- 适合存储稠密图

> 邻接表法

- 适合存储稀疏图

### 图的遍历

> 广度优先搜索BFS(Breadth-First-Search)

- 类似二叉树的层序遍历算法
- 先访问起始顶点v，然后依次访问与v相邻的顶点，然后再依次从这些顶点出发访问
- 算法的实现借助辅助队列

~~~ c
bool visited[MAX_VERTEX_NUM]; //访问标记数组
void BFSTraverse(Graph G){ //对图进行广度优先遍历
    for(i=0;i<G.vexnum;++i)
        visited[i]=FALSE; //访问标记数组初始化
    InitQueue(Q);  //初始化辅助队列Q
    for(i=0;i<G.vernum;++i) //从0号顶点开始遍历
        if(!visited) //对每个连通分量调用一次BFS
            BFS(G,i);
}
void BFS(Graph G,int v){
    visit(v); //访问初始顶点v
    visited[v]=TRUE; //对v做已访问标记
    EnQueue(Q,v);  //顶点v入队列
    while(!isEmpty(Q)){ 
        DeQueue(Q,v); //顶点v出队列
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)) //检测v所有邻接点
            if(!visited[w]){ //w为v的尚未访问的邻接顶点
                visit(w); //访问顶点w
                visited[w]=True; //对w做已访问标记
                EnQueue(Q,w); //顶点w入队
            }
    }
}
~~~

> 深度优先搜索DFS(Depth-First-Search)

- 类似于树的先序遍历，尽可能“深”地搜索一个图

~~~c
bool visited[MAX_VERTEX_NUM];
void DFSTraverse(Graph G){
    for (v=0;v<G.vernum;++v)
        visited[v]=False;
    for (v=0;v<G.vernum;++v)
        if(!visited[v])
            DFS(G,v);
}
void DFS(Graph G,int v){
    visit(v);
    visited[v]=TRUE;
    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
        if(!visited[w]){
            DFS(G,w);
        }
}
~~~

### 最小生成树

- 权值最小的生成树，即最小生成树
- 最小生成树不是唯一的，但是其权值之和是唯一的，其边数为顶点数减1

> Prim普里姆算法

- **从图中任取一个顶点，然后选择与其最近的顶点构成树，直至所有的顶点都并入**
- 时间复杂度为O(v^2),适用于求解边稠密的图

> Kruskal克鲁斯卡尔算法

- **按照权值从小到大的顺序，每次选择权值最小的边构成树**
- 时间复杂度为O(Elog2E),适用于边稀疏而顶点较多的图

### 有向无环图

- 若一个有向图中不存在环，就称为有向无环图

### 拓扑排序

- 是对有向无环图的顶点的一种排序，每次选择入度为0的顶点

### 关键路径

- 在带权有向图中，具有最大路径长度的路径称为关键路径

------

## 第七章 查找

### 顺序查找

- 又称线性查找，最直观的查找方法，逐个检查
- 对于**一般线性表的顺序查找**，ASL成功=(n+1)/2，ASL不成功=n+1
- 对于**有序表的顺序查找**，ASL成功与一般线性表相同，不成功的ASL为n/2+n/(n+1)【顺序查找判定树】

~~~ c
typedef struct{
    Elemtype *elem;
    int TableLen;
}SSTable;
int Search_Seq(SSTable ST,Elemtype key){
    ST.elem[0]=key //哨兵，0号单元留空
    for (i=ST.TableLen;ST.elem[i]!=key;--i);
    return i; //如果是0就说明表中无key元素，查到了哨兵
}
~~~

### 折半查找

- 折半查找又称二分查找，仅适用于**有序的顺序表**。

~~~ c
int Binary_Search(SeqList L,Elemtype key){
    int low=0,high=L.TableLen-1,mid;
    while(low<=high){
        mid=(low+high)/2;
        if (L.elem[mid]==key)
            return mid;
        else if (L.elem[mid]>key)
            high=mid-1;
        else
            low=mid+1;
    }
    return -1; //查找失败
}
~~~

- 时间复杂度：O(log2n)，比顺序查找效率高
- ASL的计算画出判定树即可

### 哈希查找

- 散列函数建立了关键字和地址之间的映射关系

- **散列函数的构造方法**有：直接定址法、**除留余数法**、数字分析法和平方取中法

- **处理冲突的方法**有：

  1. **开放定址法**，指其他空闲地址既对它的同义词表项开放，也对他的**非同义词表项**开放，增量序列可以是：

  > **线性探测法**(容易造成聚集，降低查找效率)
  >
  > d=0,1,2,3,4……

  2. **拉链法**：存储在线性链表中，线性链表由散列地址标识。

- ASL模拟一下就知道了

------

## 第八章 排序

### 直接插入排序

- 简单直接

  ~~~c
  void InsertSort(Elemtype A[],int n){
      int i,j;
     	for(i=2;i<=n;i++){
          if(A[i]<A[i-1]){
              A[0]=A[i];
              for(j=i-1;A[0]<A[j];--j)
                  A[j+1]=A[j];
              A[j+1]=A[0];
          }
      }
  }
  ~~~

### 希尔排序

- 又称缩小增量排序

  ~~~c
  void ShellSort(ElemType A[],int n){
      for(dk=n/2;dk>=1;dk=dk/2);
      	for(i=dk+1;i<=n;++i)
              if(A[i]<A[i-dk]){
                  A[0]=A[i];
                  for(j=i-dk;j>0&&A[0]<A[j];j-=dk)
                      A[j+dk]=A[j];
                 	A[J+dk]=A[0];
              }
  }
  ~~~

### 快速排序

### 简单选择排序

### 堆排序

### 归并排序

### 各种排序方法的比较

- **排序趟数**与序列的初始状态无关的排序方法有：
  1. 直接插入排序
  2. 折半插入排序
  3. 希尔排序
  4. 简单选择排序
  5. 归并排序
- 元素的**比较次数**和序列的初始状态无关的排序方法有：
  1. 简单选择排序
  2. 归并排序

------