[TOC]

# 数据库部分

------
## 第一章 数据库概论

--------------------------

### ***数据库的由来和发展***
> 数据管理技术的发展经历了**人工管理、文件系统、数据库阶段**和高级数据库阶段
#### 人工管理阶段(数据与程序不具有独立性)
- 数据不保存在计算机内，计算机主要用于计算
- 没有专用的软件对数据进行管理，数据与程序不具有独立性，存储结构改变时，应用程序必须改变
- 只有程序的概念，没有文件的概念
#### 文件系统阶段(有了基本的设备独立性)
- 数据的逻辑结构与物理结构有了区别，程序与数据之间具有“设备独立性”
- 数据不再属于某个特定的程序，可以重复使用，数据面向应用

**但还存在缺陷：**

1. **数据冗余**
2. **数据不一致**
3. **数据联系弱**

#### 数据库阶段

- 采用数据模型表示复杂的数据结构
- 有较高的数据独立性
- 数据库系统为用户提供了方便的用户接口

-----

### *数据抽象的级别*

- ※数据模型是由**数据结构、数据操作、完整性约束**三部分组成。

#### 关系模型

- 用二维表格表达实体集
- 用关键码导航数据
- 查询语言是非过程性语言

-----------------

### *※三层模式和两级映像(非常抽象。。。)*

#### 三层模式体系结构

- **外模式是用户和数据库系统的接口，外模式是逻辑模式的逻辑子集**
- **逻辑模式是数据库中全部数据的整体逻辑结构的描述**
- **内模式是数据库在物理存储方面的描述**(存放在外存里的实际数据，DBMS从物理数据库中构造出概念数据库和用户数据库！！)

#### 两级映像

- 外模式/逻辑模式映像存在于外模式和逻辑模式之间，用于定义外模式和逻辑模式之间的对应性。
- 逻辑模式/内模式映像存在于逻辑模式和内模式之间，用于定义逻辑模式和内模式之间的对应性。

> 数据库的三层模式和两级映像结构称为”数据库的体系结构“

-----
### ※数据独立性(对上级模式的独立)

> ※**应用程序和数据库的数据结构**之间相互独立，不受影响，在修改数据结构时，尽可能不修改应用程序，则称系统达到了数据独立性目标。

- 物理数据独立性：对内模式的修改尽量不影响逻辑模式，只需对映像做修改
- 逻辑数据独立性：对逻辑模式的修改尽量不影响外模式和应用程序，只需对映像做修改

### DBMS


>  DMBS的主要功能：**数据库的定义功能DDL，数据库的操纵功能DML**，**数据库的保护功能**(恢复，并发控制，完整性控制，安全性控制)，**数据库的维护功能**和**数据字典**(在执行查询语句时，DBMS从数据字典中调出相应的内模式描述，并从模式映像到内模式，从而确定读入的物理数据)

- DBMS是位于**用户**和**操作系统**之间的一层管理软件。

------
## 第二章 关系模型和关系运算理论

### 关系模型的基本概念(关系模型是一种逻辑模型！)

> 用二维表格表示实体集，用关键码表示实体之间联系的数据模型称为关系模型

- 关系中属性的个数称为“元数”，元组个数称为“基数”
- 关系模型由**数据结构**、**数据操作**、**完整性规则**组成。
- 关系数据库中可命名的最小单位是**属性**
- 关系名和它的**属性集**称为关系模式。
- 传统的集合运算有**并、差、交、笛卡尔积**。
- 基本的运算有**并、差、选择、投影、笛卡尔积。**
- 专门的关系运算有**选择、投影、连接、除**

### 关系模型的三类完整性规则

- **实体完整性规则**
- **参照完整性规则**(外键)
- **用户定义的完整性规则**

### 关系代数表达式的启发式优化算法

- 尽可能早地执行选择操作
- 尽可能早地执行投影操作
- 避免直接做笛卡尔积

------
## 第三章 关系数据库语言SQL

### SQL概念

- 非过程化语言
- SQL语言具有**数据定义、数据操纵、数据控制**的功能DDL DML DCL
- 

### SQL的数据定义

- 创建语句，如果是主键可以不写NOT NULL

~~~sql
CREATE TABLE SC(
	S# CHAR(4),
    C# CHAR(4),
    SCORE SMALLINT,
    PRIMARY KEY(S#,C#),
    FOREIGN KEY(S#) REFERENCES S(S#);
    FOREIGN KEY(C#) REFERENCES C(C#));
~~~

- 基本表结构的修改

~~~sql
ALTER TABLE S ADD ADDRESS VARCHAR(30);
ALTER TABLE S DROP AGE CASCADE/RESTRICT[级联：所有引用到的视图和约束也一起删除/限制：在没有视图或约束引用时才允许删除];
ALTER TABLE S MODIFY S# CHAR(6);
~~~

- **索引的创建**

~~~sql
CREATE UNIQUE INDEX S#_INDEX ON S(S#) //UNIQUE代表每个索引值对应唯一的数据记录
DROP INDEX S_INDEX
~~~

### 数据更新

- 数据插入

~~~sql
INSERT INTO S(S#,SNAME,AGE,SEX)
    VALUES('S36','GU',20,'M');
~~~

- 数据删除

~~~sql
DELETE FROM SC WHERE C# IN (SELECT C# FROM C WHERE CNAME='MATHS');
~~~

- 数据修改

~~~sql
UPDATE SC SET SCORE=SCORE*1.5
	WHERE C#='C4'
	 AND SCORE<(SELECT AVG(SCORE)
               	FROM SC
               	WHERE C#='C4')
~~~

### 视图

~~~sql
CREATE VIEW STUDENT_SCORE(S#,SNAME,CNAME,SCORE)
       AS SELECT S#,SNAME,CNAME,SCORE
          FROM S,SC,C
          WHERE S.S#=SC.S# AND SC.C#=C.C#
DROP VIEW STUDENT_SCORE
~~~

- 如果视图是从单个基本表只使用选择、投影操作导出的，**并且包含了基本表的主键**，那么这样的视图称为“**行列子集视图**”，并且可以被执行更新操作，并且允许用户更新的视图在定义时必须加上**“WITH CHECK OPTION"****短语。



------
## 第四章 关系数据库的规范化设计

- 在有泛关系假设时，对数据库中的关系进行自然连接后多出来的元组称为**寄生元组**，表示的是错误的信息。
- 在无泛关系假设时，对两个关系进行自然连接中被丢失的元组称为悬挂元组，**悬挂元组**是造成两个关系不存在泛关系的原因。
- 关系模式在分解时应保持“等价”，有**数据等价**和**语义等价**，分别用**无损分解**和**保持依赖**两个特征来衡量。

> 第二范式2NF：每个非主属性都完全函数依赖于候选码
> - **不满足2NF的关系模式中必定存在非主属性对关键码的局部依赖**

> 第三范式3NF：每个非主属性都非传递函数依赖于候选码
> - 不满足3NF的关系模式中必定存在非主属性对关键码的传递依赖
> - 等价定义：**对于F中每个非平凡的FD X->Y，都有X是R的超键，或者Y的每个属性都是主属性，也即3NF**

> BCNF:每个属性都不传递依赖于R的候选键
> - 等价定义：**对于F的每个非平凡的FD X->Y 都有X是R的超键，也即BCNF**

> 1. **FD左边是否都是超键** BCNF
> 2. **左边都是超键或者右边都是主属性** 3NF
> 3. **任何候选码的真子集都不能推出非主属性** 2NF

![](https://cdn.jsdelivr.net/gh/donladon/img/img/@P1CR_I2YME1~QFUZ]H$15K.png)

- 3NF**仍存在一定的插入和删除异常**
- BCNF的关系模式**在函数依赖范畴内已消除了插入和删除的异常**。
- 如果属性全都是主属性，则R必定是3NF
- ※**任何一个包含两个属性的关系模式一定满足BCNF**
- 如果候选码由单属性构成，则至少是2NF。
- 若函数依集中所有候选关键字都是决定因素，则R是BCNF。

### 1. 求最小函数依赖集
1. 分解规则，将右边化为单属性
2. 删去左边冗余的属性
3. 删除冗余的属性，假设删去第一个、第二个……会不会有影响

### 2.分解成3NF,无损分解且保持函数依赖
1. 先求出F的最小依赖集，然后将左部相同的FD合并起来
2. 在最小依赖集中，每个FD X->Y 去构成一个模式XY。
3. 在构成的模式集中，如果每个模式都不包含R的候选键，那么把候选键作为一个模式放入模式集中。

### 3.求候选键(类似极大线性无关组的理解)

> ![](https://cdn.jsdelivr.net/gh/donladon/img/img/202210030028526.png)

- **给定关系模式R(U,F),将R的所有属性分为L,R,LR和N四类**
- **令X=L∪N，求X的闭包，若X的闭包包含了R的所有属性，则X为R的唯一候选码**
- **选LR中属性，求闭包，继续这一过程**

------
## 第五章 数据库设计与ER模型

### 数据库设计的全过程

> 规划、需求分析、概念设计、逻辑设计、物理设计、实现、运行维护

#### 规划阶段

- 系统调查、可行性分析、确定数据库系统的总目标

#### 需求分析

- 业务流程图，系统关联图，**数据流图，数据字典**(数据项，数据结构，数据流，数据存储和处理过程)

#### 概念设计阶段

- 产生概念模型（ER模型）

#### 逻辑设计阶段

- 把概念模型转换成DBMS成处理的逻辑模型：（ER模型->关系模型）

#### 物理设计阶段

- 对于给定的数据模型选取一个最适合应用环境的物理结构的过程。

-------

- 建立数据流图是需求分析的主要任务
- 建立E-R图是概念设计的主要任务
- 创建数据库说明是逻辑设计的主要任务
- 数据库实施阶段的主要任务是建立数据库、加载数据和系统调试

-----

- 当局部ER图合并成全局ER图时，可能出现**属性冲突，结构冲突，命名冲突**
- 采用关系模型的逻辑结构设计的任务是将ER图转换成一组**关系模式**，并进行**规范化处理**。

------
## 第七章 系统实现技术

### 事务

- DBMS运行的最小逻辑工作单位是“**事务**”
- 在程序中，事务以**BEGIN TRANSACTION**语句开始，以**COMMIT**和**ROLLBACK**语句结束。

-----
#### ACID性质(十元一晚隔空舅父)：
> - 原子性(Atomicity)：一个事务对数据库的所有操作，是一个不可分割的工作单元。这些操作要么全部执行，要么什么都不做。由DBMS的**事务管理子系统**来实现。
> - 一致性(Consistency):一个事务独立执行的结果，应保持数据库的一致性，即数据不会因事务的执行而遭受破坏。由DBMS的**完整性子系统**执行测试任务。
> - 隔离性(Isolation):在多个事务并发执行时，系统应保证与这些事务先后单独执行时的结果一样，此时称事务达到了隔离性的要求。由DBMS的**并发控制子系统**实现。
> - 持久性(Durability):一个事务一旦完成全部操作后，它对数据库的所有更新应永久地反映在数据库中，不会丢失。即使以后系统发生故障，也是如此。由DBMS的**恢复管理子系统**来实现。

### 恢复

- 系统能把数据库从被破坏、不正确的状态恢复到最近一个正确的状态，DBMS的这种能力称为数据库的**可恢复性**。
- 数据库系统在运行过程中，可能会发生各种故障，主要有**系统故障**，**事务故障**，**介质故障**和**计算机病毒**四类。
- 数据库恢复的基础是利用转储的**冗余数据**，包括**日志文件**和**数据库后援副本**。
- 制作后援副本的过程称为**转储**。它又分为**增量转储**和**海量转储**。
- 事务故障、系统故障的恢复是由**系统自动**完成的，介质故障是由**DBA执行恢复操作过程**完成的

### 并发控制(丢脏腑)

- 丢失更新问题
- 读脏数据问题：在数据库技术中，把未提交的随后被撤销的数据称为“脏数据”。
- 不可重复读

#### 封锁技术

- 排他型封锁（X锁）又称**写锁**，可以解决**丢失更新**问题。
- 申请X锁操作XFIND R，解除X锁操作XRELEASE R

-----

- 共享型封锁（S锁）又称**读锁**，加上S锁后仍允许其他事务再对该数据加S锁，但在对该数据的所有S锁都解除之前决不允许任何事务对该数据加X锁。
- 申请S锁操作SFIND R，升级和写操作UPDX R，解除S锁操作SRELEASE R
- 使用S锁技术也可以解决**丢失更新**问题，但同时又可能会引起另外一个问题——**死锁**。

-----

- 封锁对象的大小称为封锁的**粒度**。
- 事务在修改数据R之前必须先对其加X锁，直到事务结束才释放，称为**一级封锁协议**。
- **二级封锁协议**是在一级协议的基础上加上，事务T在读数据R之前必须先对其加S锁，读完后即可释放S锁。
- **三级封锁协议**是在一级协议的基础上加上，事务T在读数据R之前必须先对其加S锁，直到事务结束后才释放S锁。
- **一级封锁协议**可以解决丢失更新
- **二级封锁协议**可以解决丢失更新，读脏数据
- **三级封锁协议**可以解决丢失更新，读脏数据，不可重复读问题。

-----

> 封锁带来的问题：
>
> - **活锁**：**系统可能使某个事务永远处于等待状态，得不到执行的机会，这种现象称为“活锁”。**解决活锁问题的一种简单的方法是采用“先来先服务”的策略。
> - “饿死”问题：有可能存在一个事务序列，其中每个事务都申请对某数据项加S锁，且每个事务在授权加锁后的一小段时间内释放封锁，此时若另有一个事务T2欲在该数据项上加X锁，则将永远轮不上封锁的机会，这种现象称为“饿死”。
> - “死锁”问题：**系统中有两个或两个以上的事务都处于等待状态**，并且每个事务都在等待其中另一个事务解除封锁，它才能继续下去，结果造成任何一个事务都无法继续执行，这种现象称系统进入了“死锁”状态。

- 事务的执行次序称为“**调度**”，如果多个事务依次执行，则称为事务的**串行调度**，如果利用分时的方法同时处理多个事务，则称为事务的**并发调度**。
- 如果有n个事务串行调度，可有n！种不同的有效调度。
- 如果有n个事务并发调度，可能的并发调度数目远远大于n！。

-----

- 如何判断一个并发调度是正确的，用**并发调度的可串行化**概念解决。
- 每个事务中，语句的先后顺序在各种调度中始终保持一致。在这个前提下，如果一个并发调度的执行结果与某一串行调度的执行结果等价，那么这个并发调度称为“**可串行化的调度**“，否则是不可串行化的调度。

### 数据库的完整性

- （真笑容）数据库中完整性一词是指数据的**正确性**（correctness），**有效性**（validity）和**相容性（consistency）**，防止错误的数据进入数据库。
- SQL中的**完整性约束**分为三大类：**域约束、基本表约束和断言**
- 基本表约束有三种形式：**候选键定义，外键定义和检查约束定义（check）**。

### 数据库的安全性

- SQL中有四个机制提供了安全性：视图，权限，角色和审计

### 使用SQL创建用户和授权

~~~sql
GRANT SELECT,UPDATE ON S TO WANG WITH GRANT OPTION
GRANT INSERT(S#,C#) ON SC TO LOU WITH GRANT OPTION
GRANT UPDATE(SCORE) ON SC TO WEN
#允许用户BAO在建立新关系时，引用关系C的主键C#作为新关系的外键，并有转让权限             
GRANT REFERENCES (C#) ON C TO BAO WITH GRANT OPTION
#允许用户CHEN使用已定义过的域AGE                  
GRANT USAGE ON DOMAIN AGE TO CHEN                  
~~~

~~~sql
REVOKE SELECT,UPDATE ON S FROM WANG CASCADE#CASCADE代表连锁回收，将转授出去的权限一并收回RESTRICT代表如果权限已转让过，那么回收失败
REVOKE GRANT OPTION FOR REFERENCES(C#) ON C FROM BAO #代表收回转授权，REVOKE GRANT OPTION FOR代替了REVOKE
~~~



------